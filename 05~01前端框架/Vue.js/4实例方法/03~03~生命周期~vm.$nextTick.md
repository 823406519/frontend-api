
## vm.$nextTick([callback])
```js
/*
[callback]: {Function}

将回调函数的调用延迟到下一次DOM更新周期(next dom update cycle)

修改数据之后立即使用它，以等待DOM更新

全局的Vue.nextTick 与之是相同的，不同的是回调函数的this自动绑定到实例上
*/
vm.$nextTick([callback])

// ==== example
new Vue({
  // ...
  methods: {
    // ...
    example: function () {
      // modify data
      this.message = 'changed'
      // DOM is not updated yet
      this.$nextTick(function () {
        // DOM is now updated
        // `this` is bound to the current instance
        this.doSomethingElse()
      })
    }
  }
})
```

## nextTick
这样一个场景：假如div上v-if初始为假值，即取反v-if的值从而使得div创建前，是不能获取到这个元素。

```html
<div v-if="flag">文本</div>
<button @click="getText">get text<button>

<!-- 
vue 观测数据变化时，不是直接更新，而是开启一个异步更新队列，缓冲同一事件循环的所有改变
，缓冲时会去除重复数据，避免不必要的DOM操作，然后再下一循环tick中，刷新都列并执行工作。

理论上，不应该去主动操作DOM，主动操作DOM就要注意vue的异步更新队列原理。，。

 -->
method：{
  getText(){
    this.flag = !this.flag;
    let text = document.querySelector('div').textContent;
    console.log(text);
  }
}
```
