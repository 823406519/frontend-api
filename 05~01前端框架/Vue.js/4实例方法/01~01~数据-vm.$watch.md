
## vm.$watch()
```js
/*
1. expOrFn：{string | Function}
watch Vue 实例的expression或者计算属性function

2. callback：{Function | Object}
回调函数可以接受newVal或者oldVal， 表达式只接受使用.分隔符，
更复杂度的表达式使用函数代替

注意：当改变一个对象或者数组上，old value 和 new value 是相同的，
因为的引用是相同的。vue 不会保存变化之前的副本

3. [options]：{Object}
*/
vm.$watch(expOrFn, callback, [options])

/*
return `{Function} unwatch`, 用来停止触发回调
*/
var unwatch = vm.$watch('a', cb)
// later, teardown the watcher
unwatch()


// === example
// keypath
vm.$watch('a.b.c', function (newVal, oldVal) {
  // do something
})

vm.$watch(
  function () {
    // every time the expression `this.a + this.b` yields a different result,
    // the handler will be called. It's as if we were watching a computed
    // property without defining the computed property itself
    return this.a + this.b
  },
  function (newVal, oldVal) {
    // do something
  }
)
```

## 选项
```js
// deep
// wathch对象的内部值的变化，需要指定deep:true
vm.$watch('someObject', callback, {
  deep: true
})
vm.someObject.nestedValue = 123
// callback is fired

// option: immediate
// 指定 immediate:true 以表达式的当前值立即触发回调

vm.$watch('a', callback, {
  immediate: true
})
// `callback` is fired immediately with current value of `a`

// 注意，当immediate:true 时在回调中调用unwatch函数导致报错
// 如果仍然希望在回调中调用unwatch，需要首先判断是否能够访问
var unwatch = vm.$watch(
  'value',
  function () {
    doSomething()
    if (unwatch) {
      unwatch()
    }
  },
  { immediate: true }
)

```