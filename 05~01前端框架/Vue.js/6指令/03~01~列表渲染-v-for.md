
## v-for
1. 期望：`Array | Object | number | string | Iterable`
2. 描述：根据源数据多次渲染元素或者template block


`v-for`的默认行为尝试在修改元素的时候不移动他们。需要重排序的元素，需要提供`key`属性作为排序提示

Vue 2.6+ 后， 可以实现可迭代协议(iterable protocol)的值，包括原生的map 和 set

列表渲染比条件渲染具有更高的优先级别

```html
<!-- 数组列表渲染 -->
<div v-for="item in items">
  {{ item.text }}
</div>
<div v-for="(item, index) in items"></div>

<!-- 对象列表渲染 -->
<div v-for="(val, key) in object"></div>
<div v-for="(val, name, index) in object"></div>

<!-- 也可以使用 of 代替 in, 使得它更加接近javascript的语法 -->
<div v-for="item of items"></div>

<!-- key作为排序提示 -->
<div v-for="item in items" :key="item.id">
  {{ item.text }}
</div>
```

## 维护状态的控制
更新使用 v-for 渲染的元素列表时，默认使用“就地更新”的策略。如果data item的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保反映了在每个索引位置正确渲染的内容。

默认的这种模式是很高效的，**但是仅适用于列表渲染的输出不依赖于子组件或者临时DOM状态（例如 form input value）**

为了跟踪每个节点，重用和重新排序现有元素，需要为每项提供一个唯一 key 属性。建议尽可能使用`v-for`时配合`key`属性使用，除非DOM的迭代内容很简单或者需要依赖于默认行为提高性能。

注意，不要使用非基本值（e.g object or array)作为`v-for`的key，使用`Number | String` 值
```html
<div v-for="item in items" v-bind:key="item.id">
  <!-- 内容 -->
</div>
```

## 数组更新检测
vue 包装了(wrap)了一些数组变异(mutation)的方法去改变视图，包装方法如下
* push()
* pop()
* shift()
* unshift()
* splice()
* sort()
* reverse()

与变异方法对应的是非变异方法。(non-mutating method) 方法，不会改变原始数组，而总是返回一个新数组，`e.g. filter(), concat() and slice()`。当使用非变异方法时，可以用新数组替换旧数组触发数组更新


```js
// vue不能检查下面数组的改变：
// 1. `vm.items[indexOfItem] = newValue` 通过数组下标赋值不能触发更新
// 解决办法如下
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set 是全局Vue.set的别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)


// 2. `vm.items.length = newLength` 修改数组长度
vm.items.splice(newLength)
```


## 对象变更检测
```js
var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` is now reactive

vm.b = 2
// `vm.b` is NOT reactive

//  ===== Vue 不能检测对象属性的添加或删除，解决办法
var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})
Vue.set(vm.userProfile, 'age', 27)
// vm.$set instance method, which is an alias for the global Vue.set
vm.$set(vm.userProfile, 'age', 27)

// 有时你可能需要为已有对象增加多个新属性
Object.assign(vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
// 增加新的，响应式的属性
vm.userProfile = Object.assign({}, vm.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
```

## 显示过滤/排序后的结果
要显示一个数组经过过滤或排序后的结果，而不实际改变或重置原始数据，可以通过使用计算属性

```js
<li v-for="n in evenNumbers">{{ n }}</li>
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}

// 如果计算属性不合适，可以使用方法
// 注意是方法需要调用
<li v-for="n in even(numbers)">{{ n }}</li>
data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}
```

## 在 <template> 上使用 v-for
类似于 v-if，你也可以利用带有 v-for 的 <template> 来循环渲染包含多个元素的内容


## 在组件上使用v-for
```html
<!-- 在组件上使用v-for与普通元素一样 -->
<!-- 在组件上使用v-for, key 属性是必须的 -->
<my-component v-for="item in items" :key="item.id"></my-component>
```

## v-for 与 v-if
不建议同时使用 v-if 和 v-for，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。这意味着v-if会在每一个迭代中运行
