## 计算属性例子
```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```
Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新

## 计算属性缓存 vs 方法
计算属性是**基于它们的响应式依赖**进行缓存的, 为了达到计算属性的效果，调用方法来达到同样的效果
```html
<p>Reversed message: "{{ reversedMessage() }}"</p>
```
为什么需要缓存？有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！

## 计算属性 vs 侦听属性
一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性，一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性，通常更好的做法是使用计算属性而不是命令式的 watch 回调

例子
```html
<div id="demo">{{ fullName }}</div>
```
```js
// 代码是命令式且重复的
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})
```

```js
// 计算属性版本，精简了一点
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

## 计算属性的 setter
计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter
```js
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
```