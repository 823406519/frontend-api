
## 堆排序
对于简单选择排序，待排序的n个记录中选择一个最小的记录需要比较n-1词，但在后一趟的操作中，又重复了其中的一些操作。


堆排序 (Heap sort) 就是利用堆(假设利用大顶堆)进行排序的方法：
* 将待排序的序列构造成一个大顶堆。此时，整个序列最大值就是堆顶的根元素
* 将根节点与末尾元素交换，然后将堆的大小减小1，然后将剩余的n-1个序列构成一个堆，得到n个元素的次小值
* 反复执行，直到排序完成

堆排序的平均时间复杂度为 Ο(nlogn)


* 针对单个堆节点



基本思想是构建初始堆，再进行堆构造。
  * 第1个循环，。循环从[list.length/2]开始，要完成的就是将现在的待排序序列构建成一个大顶堆，因为从[list.length/2] -> 1的循环，节点都是有孩子的点，可以通过它自身，关联到它的孩子节点。
    ```js
    // 构建大顶堆
    function buildHeal(list, now, length){
      let temp = list[now]; // now = list.length/2 ->1
      // 沿着较大点向下筛选
      for(let i = 2 * now; i<length; i= 2*i){
        if(list[i] < list[i+1]) i++;
        if(temp > list[i]) break;
        list[now] = list[i];  // 节点的值为左右孩子的最大值
        now = i // 记录下当前的位置，循环结束后替换
      }
      list[i] = temp
    }
    ```
  
  * 第2个循环要完成的就是逐步将根节点与末尾元素交换，然后调用buildHeal调整其为大顶堆。
    ```js
    for(i = list.length; i > 1; i--){
      swap(list, i-1)
      buildHead(list, 1, i-1)
    }
    ```