## 创建对象的方式
1. Object.create(proto)

```js
// 对象字面量
let obj = {
  // ...
}

// Object内置引用类型
let obj = new Object();
obj.attribute = value;

// 工厂函数
// 可以多次调用，却不可以解决对象识别（如何识别对象的类型）
function createObj(...args){
  let obj = new Object();
  obj.name = args[0];
  // ...
  return obj
}

// ======= 构造函数，创建特定类型的对象
function Person(...args){
  //...
}
let person = new Person()
// 缺点：不同实例上的同名函数是不相等
// 借助this的机制，可以将函数的定义转移到构造函数外部来解决问题

```
## 原型模式创建对象
```js
// ======= 原型模式
// 每个函数都有一个prototype属性，指向一个对象
// 利用原型对象共享所有实例属性和方法
function Person(...args){
  //...
}
Person.prototype.sayName = function(){
  // ...  
}
let person = new Person()
```

## 组合使用构造函数模式和原型模式创建对象
构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存
```js
// ===== 组合使用构造函数模式和原型模式
function Person(..args){
  this.name = args;
  // ...
}
Person.prototype = {
  
  constructor: Person,
  sayName: function(){
    // ...
  },
  // ...
}
```

## 动态原型模型模式
把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型，保持了同时使用构造函数和原型的优点

```js
function Person(name, age){
  this.name = name;
  this.age = age;
  Person.prototype.sayName = function(){

  }
}
```

## 寄生构造函数模式
寄生（parasitic）构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。

除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。
```js
function Person(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  // 构造函数在不返回值的情况下，默认会返回新对象实例。
  // 而通过在构造函数的末尾添加return，可以返回指定对象
  return o;
}
var friend = new Person('Nicholas', 29, 'Software Engineer');
friend.sayName(); //"Nicholas"
```

##  稳妥构造函数模式
稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数。
```js
function Person(name, age, job) {
  //创建要返回的对象
  var o = new Object();
  //可以在这里定义私有变量和函数
  //添加方法
  o.sayName = function() {
    alert(name);
  };

  //返回对象
  return o;
}

```

