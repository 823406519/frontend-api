
## 同步代码产生阻塞
当浏览器里面的一个web应用进行密集运算，还没有把控制权返回给浏览器的时候，就会对浏览器形成阻塞，浏览器无法继续处理用户的输入并执行其他任务，直到web应用交回处理器的控制

```js
// 阻塞的例子
const btn = document.querySelector('button');
btn.addEventListener('click', () => {
  let myDate;
  // 当按钮被点击，它就开始运行一个非常耗时的任务,计算1千万个日期，并在console里）
  for (let i = 0; i < 10000000; i++) {
    let date = new Date();
    myDate = date;
  }

  //显示最后一个日期
  console.log(myDate);

  // 显示最后一个日期
  let pElem = document.createElement('p');
  pElem.textContent = 'This is a newly-added paragraph.';
  document.body.appendChild(pElem);
});
```

## 线程
一个线程是一个基本的处理过程，程序用它来完成任务。每个线程一次只能执行一个任务:
```js
// 每个任务顺序执行，只有前面的结束了，后面的才能开始。
Task A --> Task B --> Task C

// 计算机大都有多个内核（core），因此可以同时执行多个任务。
// 持多线程的编程语言可以使用计算机的多个内核，同时完成多个任务:
Thread 1: Task A --> Task B
Thread 2: Task C --> Task D
```

JavaScript 传统上是单线程的。即使有多个内核，也只能在单一线程上运行多个任务，此线程称为主线程（main thread）

通过 Web workers 可以把一些任务交给一个名为worker的单独的线程，这样就可以同时运行多个JavaScript代码块，一般来说，用一个worker来运行一个耗时的任务，主线程就可以处理用户的交互（避免了阻塞）
```js
Main thread: Task A --> Task C
Worker thread: Expensive task B
```

## 异步代码
web workers相当有用，但是他们确实也有局限。主要的一个问题是他们不能访问 DOM — 不能让一个worker直接更新UI。

为了解决这些问题，浏览器允许我们异步运行某些操作。像Promises 这样的功能就允许让一些操作运行，直到结果返回，才进行下一步操作