屏蔽： 对象及其原型链上的相同命名属性，在原型链上层的属性被最下层的属性屏蔽，只能访问原型链中最底层的该命名属性。
# 对象属性的访问过程
```js
myObject.foo = "bar";
```
1. myObject已经有了foo属性（若原型链上层也有a属性，就会发生屏蔽）
  - 赋值会触发一个`[[Put]]`方法，对myObject的foo进行以下内容检查
    - 属性是否是访问描述符？如果是并且存在setter就调用setter
    - 属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下TypeError异常
    - 如果都不是，将该值设置为属性的值

2. 如果myObject中没有foo属性，就会遍历原型链。如果原型链上也没有找到foo属性，foo就被添加到myObject上


3. 如果myObject中没有foo属性，原型链上层有foo属性，那么有三种情况：
  - 在 `[[Prototype]]` 链上层存在名为 foo 属性, 但是已经存在了数据，没有被标记为只读（writable:true），那么会直接在对象中添加一个名为 foo的新属性，它是屏蔽属性
    ```js
    let otherObj = { foo: 1 };
    let obj = Object.create(otherObj);
    obj.foo = 2;
    console.log(otherObj); // { foo: 1 }
    console.log(obj); // { foo: 2 }
    ``` 
  - 如果在原型链的上层存在名为foo的数据属性，而writable为false,那么无法修改已有的原型链上的foo,自然无法在对象上创建屏蔽属性。严格模式下会报错，在非严格模式，这条语句会被忽略。
    ```js
    let otherObj = {};
    Object.defineProperty(otherObj, 'foo', {
      value: 1,
      writable: false
    });
    let obj = Object.create(otherObj);
    obj.foo = 2; // 非严格模式下，静默赋值无效
    console.log(otherObj.hasOwnProperty('foo')); // true
    console.log(obj.hasOwnProperty('foo')); // false

    console.log(obj.foo); // 1
    ```
  - 如果在原型链上层存在foo并且它是一个访问器属性，如果存在setter,那就一定会调用这个setter, 对象上不会发生属性屏蔽
  ```js
  // 'use strict';
  let otherObj = {};

  Object.defineProperty(otherObj, 'foo', {
    get: function() {
      return this._foo_;
    },
    set: function(val) {
      this._foo_ = val;
    }
  });

  let obj = Object.create(otherObj);
  obj.foo = 2;
  console.log(obj);  // { _foo_: 2 }
  console.log(obj.hasOwnProperty('_foo_')); // true

  console.log(obj.foo); // 2

  ```


# 隐式产生屏蔽
```JS
var anotherObject = {
  a: 2
};
var myObject = Object.create(anotherObject);
console.log(anotherObject.a); // 2
console.log(myObject.a); // 2
console.log(anotherObject.hasOwnProperty('a')); // true
console.log(myObject.hasOwnProperty('a')); // false

console.log(myObject.a++); // 隐式屏蔽！
console.log(anotherObject.a); // 2
console.log(myObject.a); // 3
console.log(myObject.hasOwnProperty('a')); // true
```
++ 操作相当于 myObject.a = myObject.a + 1。因此 ++ 操作首先会通过`[[Prototype]]`查找属性 a 并从 anotherObject.a 获取当前属性值 2，然后给这个值加 1，接着用 [[Put]]将值 3 赋给 myObject 中新建的屏蔽属性 a。