JavaScript的单线程，与它的用途有关。
  * 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。CPU大多数时候都是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
  * 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
  * 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

异步执行的运行机制如下：
1. 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）
2. 主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
3. 一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。


# 事件循环运行机制
1. 执行栈选择最先进入队列的宏任务(第一次通常是script整体代码)，如果有则执行
2. 检查是否存在 Microtask，如果存在则不停的执行，直至清空 microtask 队列
3. 更新render
4. 重复以上步骤


# 宏任务与微任务
> macrotasks: script(整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering
> microtasks: process.nextTick（Node独有）, Promise, MutationObserver
执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

## Node.js的Event Loop
Node.js的运行机制如下：
1. V8引擎解析JavaScript脚本
2. 解析后的代码，调用Node API
3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
4. V8引擎再将结果返回给用户

除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与"任务队列"有关的方法：process.nextTick和setImmediate  
  - process.nextTick方法在当前"执行栈"的尾部触发,所以指定的任务总是发生在所有异步任务之前
  - setImmediate方法则是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像


- timer 阶段: 执行到期的setTimeout / setInterval队列回调
- I/O 阶段: 执行上轮循环残流的callback
- idle, prepare
- poll: 等待回调
-   - 执行回调
-   - 执行定时器
-     - 如有到期的setTimeout / setInterval， 则返回 timer 阶段
-     - 如有setImmediate，则前往 check 阶段
- check
-   -执行setImmediate
- close callbacks

