文档参考：http://www.ruanyifeng.com/blog/2014/10/event-loop.html

## 单线程的javascript
作为作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
  > 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢
  > 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。CPU大多数时候都是空闲的。


## 浏览器事件循环
1. 调用函数的时候会产生一个执行上下文，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。
2. js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，加入与当前执行栈不同的另一个队列，我们称之为事件队列（任务队列）
3. 待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，依次执行完微任务，再依次执行一个宏任务，那么主线程会从中取出排在第一位的事件，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环...这就叫做事件循环   
  
> 注意，异步任务之间并不相同，因此他们的执行优先级也有区别不同的异步任务被分为两类：微任务（micro task）和宏任务（macro task）
  * macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering
  * microtasks: process.nextTick（Node独有）, Promise, MutationObserver

## setTimeout 延时误差
setTimeout() 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout() 指定的时间执行。所以， setTimeout() 的第二个参数表示的是最少时间，并非是确切时间。

HTML5标准规定了 setTimeout() 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒

## 浏览器事件循环例子
```js
/*
C
E
D
A
B
 */
// macrotask ['A', 'B']
// microtask ['D']
setTimeout(() => {
  console.log('A')
}, 0)
var obj = {
  func: function() {
    setTimeout(function() {
      console.log('B')
    }, 0)
    return new Promise(function(resolve) {
      console.log('C')
      resolve()
    })
  }
}
obj.func().then(function() {
  console.log('D')
})
console.log('E')

```