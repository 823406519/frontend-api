## 事件名
不同于组件和 prop，事件名不存在任何自动化的大小写转换。触发的事件名需要完全匹配监听这个事件所用的名称。v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。
**推荐始终使用 kebab-case 的事件名**


## 监听子组件事件
开发 <blog-post> 组件时，它的一些功能可能要求我们和父级组件进行沟通,例如, 引入一个辅助功能来放大博文的字号，当点击 <blog-post> 组件里面的放大按钮，所有博文的文本

Vue 实例提供了一个自定义事件的系统来解决这个问题，父级组件可以像处理 native DOM 事件一样通过 v-on 监听子组件实例的任意事件

```html
<div :style="{ fontSize: postFontSize + 'em' }">
<blog-post
  ...
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
<blog-post
  ...
  v-on:enlarge-text="postFontSize += 0.1"
></blog-post>
</div>
```

子组件可以通过调用内建的 $emit 方法 并传入事件名称来触发一个事件
```html
<button v-on:click="$emit('enlarge-text')">
  Enlarge text
</button>
```
有了这个 v-on:enlarge-text="postFontSize += 0.1" 监听器，父级组件就会接收该事件并更新 postFontSize 的值

## 使用事件抛出一个值
```html
<blog-post
  ...
  v-on:enlarge-text="postFontSize += $event"
></blog-post>

<!-- blog-post内 -->
<button v-on:click="$emit('enlarge-text', 0.1)">
  Enlarge text
</button>
```

## 在组件上使用 v-model
```html
<input v-model="searchText">
<!-- 相当于 -->
<input
  v-bind:value="searchText"
  v-on:input="searchText = $event.target.value"
>

<!-- 用在组件上时，v-model 则会这样 -->
<custom-input
  v-bind:value="searchText"
  v-on:input="searchText = $event"
></custom-input>
```


为了让它正常工作，这个组件内的 <input> 必须
* 将其 value 特性绑定到一个名叫 value 的 prop 上
* 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出
如下：
```js
Vue.component('custom-input', {
  props: ['value'],
  template: `
    <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
  `
})
```

一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value 特性用于不同的目的。model 选项可以用来避免这样的冲突
```html
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      v-bind:checked="checked"
      v-on:change="$emit('change', $event.target.checked)"
    >
  `
})
```
组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的event

```html
<base-checkbox v-model="lovingVue"></base-checkbox>
```
这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 `<base-checkbox>` 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的属性将会被更新

## 将原生事件绑定到组件
在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符
```html
<base-input v-on:focus.native="onFocus"></base-input>
```
假如 <base-input> 组件可能做了如下重构
```html
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
```
根元素实际上是一个 <label> 元素,父级的 .native 监听器将静默失败。它不会产生任何报错，onFocus 处理函数不会如你预期地被调用

Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。
```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```
现在 <base-input> 组件是一个**完全透明的包裹器**了，也就是说它可以完全像一个普通的 <input> 元素一样使用了

## .sync 修饰符
我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图
```js
this.$emit('update:title', newTitle)
```
父组件可以监听那个事件并根据需要更新一个本地的数据属性
```html
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```

为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符, 带有 .sync 修饰符的 v-bind 不能和表达式一起使用