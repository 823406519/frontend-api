## 原型链继承
原型链是实现继承的主要方法。将对象的原型对象绑定到另外一个原型对象上，从而实现对象继承

## 设置对象原型的方法
```js
/*
并不是一个最好的方法
直接让Bar.prototype 直接引用 Foo.prototype 对象
不会创建一个关联到 Bar.prototype 的新对象,
*/
Bar.prototype = Foo.prototype;

/*创建一个关联到 Bar.prototype 的新对象*/
Bar.prototype = new Foo()，

/*
Object.create(..)创建新的原型对象。
缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象
*/
Object.create(...)

Object.setPrototypeOf(Bar.prototype, Foo.prototype)
```

> 使用new Foo()创建一个父类的对象作为子类的原型对象具有一定的副作用，因为Foo构造函数内可能会有一定的副作用。
> ES6 添加了辅助函数 Object.setPrototypeOf(..)，可以用标准并且可靠的方法来修改关联



## 原型继承和经典继承方式有何不同
类继承范式中，对象实例继承从一个类上继承他们的属性和方法

对象实例通常通过使用一个构造器和 new 关键字创建

## 原型链的问题
1. **引用类型值**的原型属性会被所有实例共享。
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数
```js
// 引用类型值的原型属性会被所有实例共享
function SuperType() {
  this.colors = ['red', 'blue', 'green'];
}
function SubType() {}
//继承了 SuperType
SubType.prototype = new SuperType();
var instance1 = new SubType();
instance1.colors.push('black');
alert(instance1.colors); //"red,blue,green,black"
var instance2 = new SubType();
alert(instance2.colors); //"red,blue,green,black"
```

## 使用原型继承需要谨慎定义方法
给原型添加方法的代码一定要放在替换原型的语句之后。因为：
1. 子对象的方法和属性会覆盖掉父类同名方法和同名属性
2. 在关联子类和父类原型关系后，子类此前的原型对象会被丢弃
```js
// ==== 关联子类和父类原型关系后，子类此前的原型对象会被丢弃
function Parent() {
  // ...
  this.property = 'parent';
  this.name = 'parent'
}
function Child() {
  // ...
}

Child.prototype.property = 'child'; // 被丢弃
Child.prototype = new Parent();
let child = new Child();
child.name = 'child' // 覆盖父类属性
console.log(child.name) // child
console.log(child.property); // parent
```
## 原型链继承例子
```js
/* 
原型链上继承的优点是可以复用父类的方法以及父类的原型对象及其原型链上的方法和属性

缺点
1. 在 `Child.prototype = new Parent() 定义的原型对象的方法和属性将被覆盖
2. 无法给父类传递参数

*/

// Person 构造函数
function Parent(name) {
  this.name = name;
  this.sayHi = function() {
    console.log('parent say hi---instance method');
  };
}
// Parent 原型链
Parent.prototype.sayName = function() {
  console.log('parent name', this.name);
};
Parent.prototype.sayHello = function() {
  console.log('parent say hello ---prototype method');
};

function Child(name) {
  this.name = name;
}
Child.prototype = new Parent();
Child.prototype.constructor = Child; // important
Child.prototype.sayName = function() {
  console.log('child name', this.name);
};

let child = new Child('liuyaohiu');
child.sayName(); // child name liuyaohiu
child.sayHello(); // parent say hello---prototype method
child.sayHi(); // parent say hi---instance method
```