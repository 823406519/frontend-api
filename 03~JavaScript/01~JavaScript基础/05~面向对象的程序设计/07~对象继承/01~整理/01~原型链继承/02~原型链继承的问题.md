
## 原型链继承的问题
1. **引用类型值**的原型属性会被所有实例共享。
2. 在创建子类型的实例时，不能向超类型的构造函数中传递参数
```js
// 引用类型值的原型属性会被所有实例共享
function Parent() {
  this.colors = ['red', 'blue', 'green'];
  this.name = 'liuyaohui';
}
function Child() {} // 不能向超类型的构造函数中传递参数
//使得Child 继承Parent
Child.prototype = new Parent();
let instance1 = new Child();
instance1.colors.push('black');
instance1.name = 'liuyaohui2';

console.log(instance1.colors); //[ 'red', 'blue', 'green', 'black' ]
console.log(instance1.name); // liuyaohui2

let instance2 = new Child();
console.log(instance2.name); // liuyaohui   没有同时被修改
console.log(instance2.colors); //[ 'red', 'blue', 'green', 'black' ] 引用类型指向的值可以被改变
```

## 使用原型继承需要谨慎定义方法
给原型添加方法的代码一定要放在替换原型的语句之后。因为：
1. 子对象的方法和属性会覆盖掉父类同名方法和同名属性
2. 在关联子类和父类原型关系后，子类此前的原型对象会被丢弃
```js
// ==== 关联子类和父类原型关系后，子类此前的原型对象会被丢弃
function Parent() {
  // ...
  this.property = 'parent';
  this.name = 'parent'
}
function Child() {
  // ...
}

Child.prototype.property = 'child'; // 被丢弃
Child.prototype = new Parent();
let child = new Child();
child.name = 'child' // 覆盖父类属性
console.log(child.name) // child
console.log(child.property); // parent
```