## 借用构造函数实现继承
基本思想是在子类型构造函数的内部调用超类型构造函数，将函数的执行环境使用call和apply配合this绑定为当前实例对象。



```js
function Parent() {
  this.property = ['foo', 'bar'];
}
function Child() {
  // 在每个对象上执行初始化代码
  Parent.call(this);
}
let child = new Child();
let child2 = new Child();
child.property.push('baz');
console.log(child.property); // [ 'foo', 'bar', 'baz' ]
console.log(child2.property); // [ 'foo', 'bar']
```

## 借用构造函数实现的优点和缺点
1. 优点：子类型构造函数中向超类型构造函数传递参数
2. 缺点：在超类型的原型中定义的方法，对子类型而言也是不可见的。退而求次，方法在构造函数中定义，不利于函数的复用


## 例子
```js
/*
Parent.call(this, 父类参数)
优点：可以继承多个父类实例
缺点： 不能继承原型上的属性和方法
*/

function Parent(name) {
  this.name = name;
  this.sayHi = function() {
    console.log('Hi ' + this.name);
  };
}

Parent.prototype.syaHello = function() {
  console.log(this.name);
};

function Child(childName, parentName) {
  Parent.call(this, parentName);
  this.childName = childName;
  this.sayName = function() {
    console.log(this.childName, this.name);
  };
}

let child = new Child('liu', `liu's parent`);
child.sayName(); // liu liu's parent
child.sayHi(); // Hi liu's parent
child.sayHello(); // error
```