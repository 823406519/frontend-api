## 组合继承
组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript 中最常用的继承模式。将原型链和借用构造函数的技术组合到一块，是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性

```js
function Parent(property) {
  this.property = property;
}
function Child(property) {
  Parent.call(this, property);
}
Parent.prototype.baz = function() {
  console.log('bar');
};
Child.prototype = new Parent();
Child.prototype.constructor = Child;
let child = new Child('foo');

console.log(child.property); // foo
child.baz(); // bar

```

## 组合继承的优点和缺点
优点：保证了函数复用，又能够保证每个实例都有它自己的属性

缺点：
1. 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时  候，另一次是在子类型构造函数内部。我们不得不在调用子类型构造函数时重写这些属性
## 例子
```js
/*
将原型继承+构造继承的组合，叫做组合继承：
可以继承实例属性/方法，也可以继承原型属性/方法
调用了两次父类构造函数，初始化了两次方法和属性
*/

function Parent(name) {
  this.name = name;
  this.sayHi = function() {
    console.log('hi ' + this.name);
  };
}

Parent.prototype.sayHello = function() {
  console.log('hello ' + this.name);
};

function Child(childName, parentName) {
  Parent.call(this, parentName);
  this.childName = childName;
  this.sayName = function() {
    console.log(this.childName, this.name);
  };
}
Child.prototype = new Parent();
Child.prototype.constructor = Child;

let child = new Child('liu', `liu's parent`);

child.sayName(); // liu liu's parent
child.sayHi(); // Hi liu's parent
child.sayHello(); // hello liu's parent
```