## + 算术运算符
特殊地，执行+操作符时，按照以下步骤进行：
* 当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。
* 其他情况，当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。
* 其他情况，当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。

```js
123 + '123' // 123123   （规则1）
123 + null  // 123    （规则2）
123 + true // 124    （规则2）
123 + {}  // 123[object Object]    （规则3）
```


## == 运算符的类型转换
`==`运算符 在两侧类型不一致时会发生类型转换：
* String和Number比较，先将String转换为Number类型
* NaN和其他任何类型比较永远返回false(包括和他自己)
* Boolean和其他任何类型比较，Boolean首先被转换为Number类型，所以undefined、null和false
* 虽然都是假值，但是他们比较结果是false，原因是false首先被转换成0
* null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false
* 原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型


1. 对象与对象比较，比较内存地址
2. null 和 undefined 对比为true。与其他对比为fasle
3. 非null 和 非 undefined，ToPrimitive抽象操作。比较类型相同，直接比较
4. 比较类型不同，两边都进行 ToNumber 抽象操作。然后进行比较


先对两边进行ToPrimitive 抽象操作

结果出现非字符串，那么将两边进行 ToNumber 抽象操作

两边都是字符串类型，则按照字母顺序进行比较


```js
'[object Object]' == {} // true
'1,2,3' == [1, 2, 3] // true

// !的优先级高于==，![]首先会被转换为false
// 然后根据上面第二点false转换成Number类型0
// 左侧[]转换为0，两侧比较相等
[] == ![] // true
```