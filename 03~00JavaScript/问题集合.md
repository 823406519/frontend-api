## 如何实现异步编程
1. 回调函数
2. 事件监听
3. 发布/订阅模式
4. promise对像

## 正则表达式
```js
'a.b.c'.replace(/(.)\.(.)\.(.)/, '$2.$1.$0') // b.a.$0
// 模式匹配字符串从1开始
```

## eval
eval是将字符串解释为javascript代码并执行；应该避免使用eval，因为它会带来安全性问题，而且影响性能（一次解释，一次执行）
```js
const sum = eval('10*10+5');
console.log(typeof sum, sum); // number 105
```

## javascript读取文件
```js
// 1. ajax读取服务器文件内容，略，详细参考ajax相关内容

// 2. 读取本地计算机文件
document.getElementById('fileInput').addEventListener('change', function() {
  if (this.files) {
    let file = this.files[0];
    let reader = new FileReader();
    reader.readAsText(file);

    reader.onload = function() {
      let e = document.createElement('div');
      e.textContent = this.result;
      document.body.appendChild(e);
    };
  }
});

```

## Array.prototype.map
```js
["1", "2", "3"].map(parseInt) // [1, NaN, NaN]
/*
parseInt('1', 0) 
parseInt('1', 1)
parseInt('1', 2)
*/
```

## web-garden 和 web-farm 有什么不同 ？
web-garden 和 web-farm 都是网络托管系统。

1. web-garden 是单个服务器响应多个客户端请求，单个服务器程序包含了多个工作线程
2. web-farm是 将站点部署到负载均衡器关联的多个web服务器，同一web应用程序部署到多个服务器

## javascript 自动插入分号的问题
```js
// 在return语句后自动插入分号
function foo(){
  return
  {

  }
}
// 以上返回undefined, 因为自动插入分号

function foo(){
  return {
    //...
  }
}

// 以上返回一个对象
```

## 输出以下结果
```js
let arr1 = 'john'.split('');
let arr2 = arr1.reverse();
let arr3 = 'jones'.split('');
arr2.push(arr3);

// arr1 arr2 都指向同一个数组
// 5 [ [ 'j', 'o', 'n', 'e', 's' ] ]
console.log(arr1.length, arr1.slice(-1));

// [ 'n', 'h', 'o', 'j', [ 'j', 'o', 'n', 'e', 's' ] ]
console.log(arr2);
```

## 输出以下结果
```js
console.log(1 + '2' + '2'); // '122'

// 根据顺序，先执行+'2'
console.log(1 + +'2' + '2'); // '32'

// 先执行 - '1'
console.log(1 + -'1' + '2'); // '02'

console.log(+'1' + '1' + '2'); // 112

// 'A' - 'B' 返回NaN
console.log('A' - 'B' + '2'); // 'NaN2'
console.log('A' - 'B' + 2); // 'NaN'
```

## 输出以下结果
```js
console.log(0 || 1); // 1
console.log(1 || 2); // 1
console.log(0 && 1); // 0
console.log(1 && 2); // 2
```

## 输出以下结果
```js
let a = {}, b={key: 'b'}, c={key:'c'};
a[b] = 123;
a[c] = 456;
console.log(a[b])// 456
/*
b和c都是对象，转换为字符串为[object Object]
*/
```

## javascript 位置
```js
/* === clientHeight
只读属性，对于没有css或者是内联布局盒子的元素为0，包含内边距，不包含水平滚动条、边框和外边距
clicentHeight = css height + css pading - 水平滚动条高度
*/
element.clicentHeight
// 同理可得 clientWidth

/* === scrollHeight
只读属性，是元素内容高度的度量，值等于不使用滚动条的情况下为了适应视口中所用内容所需的最小高度

包括元素的padding，但不包括元素的border和margin
*/
element.scrollHeight

/* === scrollTop
一个元素的 scrollTop 值是这个元素的顶部到视口可见内容（的顶部）的距离的度量。
当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0
*/
element.scrollTop


// 如果元素滚动到底，下面等式返回true，没有则返回false.
element.scrollHeight - element.scrollTop === element.clientHeight
```
* clientHeight：

* offsetHeight：表示可视化区域的高度，包含border 和滚动条

* scrollHeight：表示所有区域的高度，包含了滚动条被隐藏的部分

* clientTop：表示边框border的厚度，未指定情况下为0
* scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标（css定位元素或body元素）距离顶端的高度

