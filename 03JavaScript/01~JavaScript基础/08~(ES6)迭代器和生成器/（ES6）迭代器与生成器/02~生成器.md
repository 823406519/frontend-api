
## 生成器的需求
自定义迭代器需要显式维护内部状态。而生成器函数可以定义一个包含迭代算法，内部维护自己状态。

## 生成器状态与执行上下文
1. 生成器的内部状态
  * 挂起开始(Suspended start) 生成器创建时，代码还没有执行的状态
  * 执行(Executing) 当迭代器调用 next 方法，进入这个状态
  * 挂起让渡(Suspend yield) 当遇到 yeild，返回一个对象，随后挂起
  * 完成(Completed) 遇到 return 或者代码执行结束

2. 生成器与执行上下文
  * 当生成器被构造时，它返回一个迭代器，通过引用这个迭代器，来控制生成器的执行，只要这个迭代器一直存在，生成器的环境就会一直存在
  * 当使用迭代器的 next 方法，不会像平时函数一样创建一个 next 的执行环境，而是会把生成器的环境重新放进执行栈的顶部
  * 遇到 yield 后产生一个值返回就从栈中弹出，生成器会挂起让渡
  * 下一次迭代器 next 方法会从上次离开的位置继续执行

## 生成器的创建与调用
1. 生成器创建：使用`function*`语法创建生成器函数。即进入生成器函数的挂起状态

2. 初次调用生成器，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器

3. 通过调用返回的Generator的迭代器的next方法，生成器函数将会继续执行。即进入生成器函数的执行阶段

4. 生成器执行过程中，如果遇到yield关键字，返回一个新的Generator的迭代器, 其中yield表达式的值作为迭代器value属性的值。

5. 生成器函数执行完或者遇到return，生成器函数进入完成状态。
  * 生成器函数执行完，返回一个`{value: undefined, done: true}`的迭代器对象
  * 生成器函数遇到return，则返回`{value: returnValue, done: true}`的迭代器对象，value的属性值是return 表达式的值。

> yield 只能在生成器函数内使用，在生成器内部的非生成器函数内使用也是错误的


```js
// === 例子
function* createIterator() {
  yield 1;
  yield 2;
  yield 3;
}
const iterator = createIterator(); // Object[Generator]{}  挂起开始
iterator.next(); // {value: 1, done: false}  执行 -> 挂起
iterator.next(); // {value: 2, done: false}  执行 -> 挂起
iterator.next(); // {value: 3, done: false}  执行 -> 挂起
iterator.next(); // {value: undefined, done: true} 执行 -> 挂起完成
```

## 其他形式创建生成器函数
```js
// ===== 生成器函数表达式
const iterator = function *crateIterator(){
  // ...
}
// === 注意，不能使用箭头函数创建生成器函数

// === 对象中生成器函数的缩写
let obj = {
  *createIterator(){
    // ...
  }
}
```