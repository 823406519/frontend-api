
## 组件绑定原生事件
```html
<!-- 在组件根元素上使用v-on:event-name.native -->
<base-input v-on:focus.native="onFocus"></base-input>

<!-- 这对于想监听组件内的特定元素是没有帮助的 -->
<!-- 假如 <base-input> 组件可能做了如下重构 -->
<label>
  {{ label }}
  <input
    v-bind="$attrs"
    v-bind:value="value"
    v-on:input="$emit('input', $event.target.value)"
  >
</label>
<!-- 根元素实际上是一个 <label> 元素,父级的 .native 监听器将静默失败。
它不会产生任何报错，onFocus 处理函数不会如你预期地被调用 -->
```


Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。
```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  computed: {
    inputListeners: function () {
      var vm = this
      // `Object.assign` 将所有的对象合并为一个新对象
      return Object.assign({},
        // 我们从父级添加所有的监听器
        this.$listeners,
        // 然后我们添加自定义监听器，
        // 或覆写一些监听器的行为
        {
          // 这里确保组件配合 `v-model` 的工作
          input: function (event) {
            vm.$emit('input', event.target.value)
          }
        }
      )
    }
  },
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on="inputListeners"
      >
    </label>
  `
})
```
现在 <base-input> 组件是一个**完全透明的包裹器**了，也就是说它可以完全像一个普通的 <input> 元素一样使用了

## .sync 修饰符
我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图
```js
this.$emit('update:title', newTitle)
```
父组件可以监听那个事件并根据需要更新一个本地的数据属性
```html
<text-document
  v-bind:title="doc.title"
  v-on:update:title="doc.title = $event"
></text-document>
```

为了方便起见，我们为这种模式提供一个缩写，即 `.sync` 修饰符, 带有 .sync 修饰符的 v-bind 不能和表达式一起使用