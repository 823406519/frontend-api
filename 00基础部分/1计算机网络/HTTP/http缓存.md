参考：https://juejin.im/post/5b70edd4f265da27df0938bc#heading-0

# 缓存过程
1. 浏览器第一次请求
  是否存在缓存 -> 否，向服务器发起请求 -> 获取服务器响应，存入缓存 -> 提供给客户端

2. 后续对同一URL进行请求
  是否存在缓存 -> 是 -> 判断是否命中强缓存 （cache-control和expires），如命中，直接从缓存获取资源，包括响应的 header信息，请求不会和服务器通信 -> 如果没有命中强缓存，即缓存过期。浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的 header 信息（Etag/If-None-Match和Last-Modified/If-Modified-Since）
    - 检查ETag，请求头添加if-None-Match
    - 检查Last-Modified，请求头添加if-Modified-since

  服务器进行检查，文件被修改了，发送200和新的文件；如果没被修改，发送304。该过程为协商缓存

## 缓存优点
1. 提高客户端加载速度
2. 降低服务器资源损耗

## 缓存分类
根据根据是否需要重新向服务器发起请求来分类，其分为强制缓存，对比缓存（协商缓存）
- 强制缓存在缓存数据未失效的情况下，不需要再和服务器发生交互。
- 协商缓存，需要进行比较判断是否可以使用缓存

两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行协商缓存规则。

Pragma > Cache-Control > Expires > ETag > Last-Modified

## 强制缓存相关header
1. expires 设置一个缓存失效的时间,是一个绝对时间，即下一次请求，如果请求当前时间没有达到到期时间，直接使用浏览器的缓存（Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略）。这个失效的时间是相对于服务器的时间而言的，如果人为地改变了客户端的时间，是会导致缓存失效的
 - 浏览器时间和服务器时间不同步
 - 缓存过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器
2. Cache-Control。用于控制缓存的周期。针对浏览器和服务器时间不同步，加入了新的缓存方案
 - 取值：
   - private: 客户端可以缓存
   - public: 客户端和代理服务器都可缓存
   - max-age=xxx: 缓存的内容将在 xxx 秒后失效
   - no-cache: 需要使用对比缓存来验证缓存数据
   - no-store: 所有内容都不会缓存，强制缓存，对比缓存都不会触发
 - 如果文件没有改动，再次去获取文件就有点浪费服务器的资源了
如果同时存在cache-control和Expires，浏览器总是优先使用cache-control

## 协商缓存相关header

1. Last-Modified：上一次请求时，服务器返回的字段，表示最后一次更新的时间。浏览器请求资源时就发送if-modified-since字段，服务器用本地Last-modified时间与if-modified-since时间比较，如果本地Last-modified时间在If-Modified-Since设置的时间之后，则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。

2. Etag。为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识ETag。服务器每一次返回资源，都会在Etag中存放资源的标识符，根据资源标识符来确定文件是否存在修改。下一次请求的时候将标识符放在If-None-Match中，服务端将判断是否匹配，如果不匹配，返回200以及新的资源，反之返回304，浏览器从缓存中获取资源

请求头带上了if-modified-since和if-none-match两个字段，则先判断etag，再判断last-modified



